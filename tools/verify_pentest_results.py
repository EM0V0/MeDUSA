import requests
import socket
import ssl
import time
import json
import sys
import re

# Configuration
BASE_URL = "https://zcrqexrdw1.execute-api.us-east-1.amazonaws.com/Prod"
HOSTNAME = "zcrqexrdw1.execute-api.us-east-1.amazonaws.com"

def print_header(title):
    print("\n" + "="*60)
    print(f"TEST: {title}")
    print("="*60)

def log_result(test_id, status, message):
    print(f"[{status}] {test_id}: {message}")

# --- CT37: Public Port Exposure Check (Python nmap-like scan) ---
def check_ports():
    print_header("CT37: Public Port Exposure Check")
    target_ports = [22, 80, 443, 8080]
    open_ports = []
    
    print(f"Scanning {HOSTNAME}...")
    for port in target_ports:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(1)
        result = sock.connect_ex((HOSTNAME, port))
        if result == 0:
            open_ports.append(port)
            print(f"  Port {port}: OPEN")
        else:
            print(f"  Port {port}: CLOSED")
        sock.close()
    
    if 443 in open_ports and 22 not in open_ports and 8080 not in open_ports:
        log_result("CT37", "PASS", "Only expected ports (443/80) are open. SSH/Admin ports closed.")
    else:
        log_result("CT37", "FAIL", f"Unexpected open ports found: {open_ports}")

# --- CT38: TLS Configuration Test ---
def check_tls():
    print_header("CT38: TLS Configuration Test")
    context = ssl.create_default_context()
    try:
        with socket.create_connection((HOSTNAME, 443)) as sock:
            with context.wrap_socket(sock, server_hostname=HOSTNAME) as ssock:
                version = ssock.version()
                cipher = ssock.cipher()
                print(f"  Negotiated Protocol: {version}")
                print(f"  Cipher Suite: {cipher[0]}")
                
                if version in ['TLSv1.2', 'TLSv1.3']:
                    log_result("CT38", "PASS", f"Secure TLS version negotiated: {version}")
                else:
                    log_result("CT38", "FAIL", f"Insecure TLS version: {version}")
    except Exception as e:
        log_result("CT38", "ERROR", str(e))

# --- CT47: Input Length Test (Fuzzing) ---
def check_input_length():
    print_header("CT47: Input Length Test (Fuzzing)")
    payload = {"email": "A" * 10000, "password": "password"}
    try:
        start = time.time()
        res = requests.post(f"{BASE_URL}/auth/login", json=payload)
        duration = time.time() - start
        print(f"  Sent 10k chars. Status: {res.status_code}. Time: {duration:.2f}s")
        
        if res.status_code in [403, 413, 400]: # 413 Payload Too Large is also good
            log_result("CT47", "PASS", f"Large payload blocked with status {res.status_code}")
        else:
            log_result("CT47", "WARN", f"Large payload accepted? Status: {res.status_code}")
    except Exception as e:
        log_result("CT47", "ERROR", str(e))

# --- CT93: HTTP to HTTPS Redirect ---
def check_http_redirect():
    print_header("CT93: HTTP to HTTPS Redirect")
    http_url = BASE_URL.replace("https://", "http://")
    try:
        # AWS API Gateway execute-api usually just drops HTTP on port 80 or returns 403
        # It doesn't always redirect unless CloudFront is in front.
        print(f"  Requesting {http_url}...")
        res = requests.get(http_url, timeout=5, allow_redirects=False)
        print(f"  Status: {res.status_code}")
        
        if res.status_code in [301, 302, 307, 308]:
            log_result("CT93", "PASS", f"Redirects to HTTPS (Status {res.status_code})")
        elif res.status_code == 403:
            log_result("CT93", "PASS", "HTTP Access Forbidden (Secure Default)")
        else:
            log_result("CT93", "WARN", f"HTTP returned status {res.status_code}")
    except requests.exceptions.ConnectionError:
        log_result("CT93", "PASS", "HTTP Port 80 unreachable (Secure)")
    except Exception as e:
        log_result("CT93", "INFO", f"Request failed (likely secure): {e}")

# --- CT103: Unauthenticated Access ---
def check_unauth_access():
    print_header("CT103: Unauthenticated Access")
    endpoints = [
        "/auth/health", # Might be public
        "/api/v1/doctor/patients", # Should be protected
        "/api/v1/devices" # Should be protected
    ]
    
    for ep in endpoints:
        try:
            res = requests.get(f"{BASE_URL}{ep}")
            print(f"  {ep}: {res.status_code}")
            if ep == "/auth/health":
                # Health check might be public, or 401 if strict
                pass 
            else:
                if res.status_code in [401, 403]:
                    log_result("CT103", "PASS", f"Protected endpoint {ep} blocked correctly")
                else:
                    log_result("CT103", "FAIL", f"Protected endpoint {ep} accessible! Status: {res.status_code}")
        except Exception as e:
            print(f"  Error checking {ep}: {e}")

# --- CT43: HTTP Header Security Test ---
def check_security_headers():
    print_header("CT43: HTTP Header Security Test")
    try:
        # Test a protected endpoint without token to trigger 401 UNAUTHORIZED
        # We configured API Gateway to add headers to 4xx/5xx responses
        print("  Sending GET request to /api/v1/doctor/patients (Expect 401)...")
        res = requests.get(f"{BASE_URL}/api/v1/doctor/patients") 
        headers = res.headers
        
        print(f"  Status: {res.status_code}")
        
        required_headers = [
            "Strict-Transport-Security",
            "Content-Security-Policy",
            "X-Frame-Options",
            "X-Content-Type-Options"
        ]
        
        missing = []
        for h in required_headers:
            if h in headers:
                print(f"  {h}: {headers[h]}")
            else:
                print(f"  {h}: MISSING")
                missing.append(h)
        
        if not missing:
            log_result("CT43", "PASS", "All security headers present")
        else:
            log_result("CT43", "FAIL", f"Missing headers: {missing}")
            
    except Exception as e:
        log_result("CT43", "ERROR", str(e))

if __name__ == "__main__":
    print("Starting Automated Verification Suite...")
    check_ports()
    check_tls()
    check_input_length()
    check_http_redirect()
    check_unauth_access()
    check_security_headers()
